{"/home/travis/build/npmtest/node-npmtest-node-zookeeper-client/test.js":"/* istanbul instrument in package npmtest_node_zookeeper_client */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-node-zookeeper-client/lib.npmtest_node_zookeeper_client.js":"/* istanbul instrument in package npmtest_node_zookeeper_client */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_node_zookeeper_client = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_node_zookeeper_client = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-node-zookeeper-client/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-node-zookeeper-client && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_node_zookeeper_client */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_node_zookeeper_client\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_node_zookeeper_client.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_node_zookeeper_client.rollup.js'] =\n            local.assetsDict['/assets.npmtest_node_zookeeper_client.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_node_zookeeper_client.__dirname + '/lib.npmtest_node_zookeeper_client.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-node-zookeeper-client/node_modules/node-zookeeper-client/index.js":"/**\n * Copyright (c) 2013 Yahoo! Inc. All rights reserved.\n *\n * Copyrights licensed under the MIT License. See the accompanying LICENSE file\n * for terms.\n */\n\n/**\n *\n * A pure Javascript ZooKeeper client.\n *\n * @module node-zookeeper-client\n *\n */\n\nvar assert            = require('assert');\nvar events            = require('events');\nvar util              = require('util');\nvar net               = require('net');\n\nvar async             = require('async');\nvar u                 = require('underscore');\n\nvar jute              = require('./lib/jute');\nvar ACL               = require('./lib/ACL.js');\nvar Id                = require('./lib/Id.js');\nvar Path              = require('./lib/Path.js');\nvar Event             = require('./lib/Event.js');\nvar State             = require('./lib/State.js');\nvar Permission        = require('./lib/Permission.js');\nvar CreateMode        = require('./lib/CreateMode.js');\nvar Exception         = require('./lib/Exception');\nvar Transaction       = require('./lib/Transaction.js');\nvar ConnectionManager = require('./lib/ConnectionManager.js');\n\n\n// Constants.\nvar CLIENT_DEFAULT_OPTIONS = {\n    sessionTimeout : 30000, // Default to 30 seconds.\n    spinDelay : 1000, // Defaults to 1 second.\n    retries : 0 // Defaults to 0, no retry.\n};\n\nvar DATA_SIZE_LIMIT = 1048576; // 1 mega bytes.\n\n/**\n * Default state listener to emit user-friendly events.\n */\nfunction defaultStateListener(state) {\n    switch (state) {\n    case State.DISCONNECTED:\n        this.emit('disconnected');\n        break;\n    case State.SYNC_CONNECTED:\n        this.emit('connected');\n        break;\n    case State.CONNECTED_READ_ONLY:\n        this.emit('connectedReadOnly');\n        break;\n    case State.EXPIRED:\n        this.emit('expired');\n        break;\n    case State.AUTH_FAILED:\n        this.emit('authenticationFailed');\n        break;\n    default:\n        return;\n    }\n}\n\n/**\n * Try to execute the given function 'fn'. If it fails to execute, retry for\n * 'self.options.retires' times. The duration between each retry starts at\n * 1000ms and grows exponentially as:\n *\n * duration = Math.min(1000 * Math.pow(2, attempts), sessionTimeout)\n *\n * When the given function is executed successfully or max retry has been\n * reached, an optional callback function will be invoked with the error (if\n * any) and the result.\n *\n * fn prototype:\n * function(attempts, next);\n * attempts: tells you what is the current execution attempts. It starts with 0.\n * next: You invoke the next function when complete or there is an error.\n *\n * next prototype:\n * function(error, ...);\n * error: The error you encounter in the operation.\n * other arguments: Will be passed to the optional callback\n *\n * callback prototype:\n * function(error, ...)\n *\n * @private\n * @method attempt\n * @param self {Client} an instance of zookeeper client.\n * @param fn {Function} the function to execute.\n * @param callback {Function} optional callback function.\n *\n */\nfunction attempt(self, fn, callback) {\n    var count = 0,\n        retry = true,\n        retries = self.options.retries,\n        results = {};\n\n    assert(typeof fn === 'function', 'fn must be a function.');\n\n    assert(\n        typeof retries === 'number' && retries >= 0,\n        'retries must be an integer greater or equal to 0.'\n    );\n\n    assert(typeof callback === 'function', 'callback must be a function.');\n\n    async.whilst(\n        function () {\n            return count <= retries && retry;\n        },\n        function (next) {\n            var attempts = count;\n            count += 1;\n\n            fn(attempts, function (error) {\n                var args,\n                    sessionTimeout;\n\n                results[attempts] = {};\n                results[attempts].error = error;\n\n                if (arguments.length > 1) {\n                    args = Array.prototype.slice.apply(arguments);\n                    results[attempts].args = args.slice(1);\n                }\n\n                if (error && error.code === Exception.CONNECTION_LOSS) {\n                    retry = true;\n                } else {\n                    retry = false;\n                }\n\n                if (!retry || count > retries) {\n                    // call next so we can get out the loop without delay\n                    next();\n                } else {\n                    sessionTimeout = self.connectionManager.getSessionTimeout();\n\n                    // Exponentially back-off\n                    setTimeout(\n                        next,\n                        Math.min(1000 * Math.pow(2, attempts), sessionTimeout)\n                    );\n                }\n            });\n        },\n        function (error) {\n            var args = [],\n                result = results[count - 1];\n\n            if (callback) {\n                args.push(result.error);\n                Array.prototype.push.apply(args, result.args);\n\n                callback.apply(null, args);\n            }\n        }\n    );\n}\n\n/**\n * The ZooKeeper client constructor.\n *\n * @class Client\n * @constructor\n * @param connectionString {String} ZooKeeper server ensemble string.\n * @param [options] {Object} client options.\n */\nfunction Client(connectionString, options) {\n    if (!(this instanceof Client)) {\n        return new Client(connectionString, options);\n    }\n\n    events.EventEmitter.call(this);\n\n    options = options || {};\n\n    assert(\n        connectionString && typeof connectionString === 'string',\n        'connectionString must be an non-empty string.'\n    );\n\n    assert(\n        typeof options === 'object',\n        'options must be a valid object'\n    );\n\n    options = u.defaults(u.clone(options), CLIENT_DEFAULT_OPTIONS);\n\n    this.connectionManager = new ConnectionManager(\n        connectionString,\n        options,\n        this.onConnectionManagerState.bind(this)\n    );\n\n    this.options = options;\n    this.state = State.DISCONNECTED;\n\n    this.on('state', defaultStateListener);\n}\n\nutil.inherits(Client, events.EventEmitter);\n\n/**\n * Start the client and try to connect to the ensemble.\n *\n * @method connect\n */\nClient.prototype.connect = function () {\n    this.connectionManager.connect();\n};\n\n/**\n * Shutdown the client.\n *\n * @method connect\n */\nClient.prototype.close = function () {\n    this.connectionManager.close();\n};\n\n/**\n * Private method to translate connection manager state into client state.\n */\nClient.prototype.onConnectionManagerState = function (connectionManagerState) {\n    var state;\n\n    // Convert connection state to ZooKeeper state.\n    switch (connectionManagerState) {\n    case ConnectionManager.STATES.DISCONNECTED:\n        state = State.DISCONNECTED;\n        break;\n    case ConnectionManager.STATES.CONNECTED:\n        state = State.SYNC_CONNECTED;\n        break;\n    case ConnectionManager.STATES.CONNECTED_READ_ONLY:\n        state = State.CONNECTED_READ_ONLY;\n        break;\n    case ConnectionManager.STATES.SESSION_EXPIRED:\n        state = State.EXPIRED;\n        break;\n    case ConnectionManager.STATES.AUTHENTICATION_FAILED:\n        state = State.AUTH_FAILED;\n        break;\n    default:\n        // Not a event in which client is interested, so skip it.\n        return;\n    }\n\n    if (this.state !== state) {\n        this.state = state;\n        this.emit('state', this.state);\n    }\n};\n\n/**\n * Returns the state of the client.\n *\n * @method getState\n * @return {State} the state of the client.\n */\nClient.prototype.getState = function () {\n    return this.state;\n};\n\n/**\n * Returns the session id for this client instance. The value returned is not\n * valid until the client connects to a server and may change after a\n * re-connect.\n *\n * @method getSessionId\n * @return {Buffer} the session id, 8 bytes long buffer.\n */\nClient.prototype.getSessionId = function () {\n    return this.connectionManager.getSessionId();\n};\n\n/**\n * Returns the session password for this client instance. The value returned\n * is not valid until the client connects to a server and may change after a\n * re-connect.\n *\n * @method getSessionPassword\n * @return {Buffer} the session password, 16 bytes buffer.\n */\nClient.prototype.getSessionPassword = function () {\n    return this.connectionManager.getSessionPassword();\n};\n\n/**\n * Returns the negotiated session timeout for this client instance. The value\n * returned is not valid until the client connects to a server and may change\n * after a re-connect.\n *\n * @method getSessionTimeout\n * @return {Integer} the session timeout value.\n */\nClient.prototype.getSessionTimeout = function () {\n    return this.connectionManager.getSessionTimeout();\n};\n\n\n/**\n * Add the specified scheme:auth information to this client.\n *\n * @method addAuthInfo\n * @param scheme {String} The authentication scheme.\n * @param auth {Buffer} The authentication data buffer.\n */\nClient.prototype.addAuthInfo = function (scheme, auth) {\n    assert(\n        scheme || typeof scheme === 'string',\n        'scheme must be a non-empty string.'\n    );\n\n    assert(\n        Buffer.isBuffer(auth),\n        'auth must be a valid instance of Buffer'\n    );\n\n    var buffer = new Buffer(auth.length);\n\n    auth.copy(buffer);\n    this.connectionManager.addAuthInfo(scheme, buffer);\n};\n\n/**\n * Create a node with given path, data, acls and mode.\n *\n * @method create\n * @param path {String} The node path.\n * @param [data=undefined] {Buffer} The data buffer.\n * @param [acls=ACL.OPEN_ACL_UNSAFE] {Array} An array of ACL object.\n * @param [mode=CreateMode.PERSISTENT] {CreateMode} The creation mode.\n * @param callback {Function} The callback function.\n */\nClient.prototype.create = function (path, data, acls, mode, callback) {\n    var self = this,\n        optionalArgs = [data, acls, mode, callback],\n        header,\n        payload,\n        request;\n\n    Path.validate(path);\n\n    // Reset arguments so we can reassign correct value to them.\n    data = acls = mode = callback = undefined;\n    optionalArgs.forEach(function (arg, index) {\n        if (Array.isArray(arg)) {\n            acls = arg;\n        } else if (typeof arg === 'number') {\n            mode = arg;\n        } else if (Buffer.isBuffer(arg)) {\n            data = arg;\n        } else if (typeof arg === 'function') {\n            callback = arg;\n        }\n    });\n\n    assert(\n        typeof callback === 'function',\n        'callback must be a function.'\n    );\n\n    acls = Array.isArray(acls) ? acls : ACL.OPEN_ACL_UNSAFE;\n    mode = typeof mode === 'number' ? mode : CreateMode.PERSISTENT;\n\n    assert(\n        data === null || data === undefined || Buffer.isBuffer(data),\n        'data must be a valid buffer, null or undefined.'\n    );\n\n    if (Buffer.isBuffer(data)) {\n        assert(\n            data.length <= DATA_SIZE_LIMIT,\n            'data must be equal of smaller than ' + DATA_SIZE_LIMIT + ' bytes.'\n        );\n    }\n\n    assert(acls.length > 0, 'acls must be a non-empty array.');\n\n    header = new jute.protocol.RequestHeader();\n    header.type = jute.OP_CODES.CREATE;\n\n    payload = new jute.protocol.CreateRequest();\n    payload.path = path;\n    payload.acl = acls.map(function (item) {\n        return item.toRecord();\n    });\n    payload.flags = mode;\n\n    if (Buffer.isBuffer(data)) {\n        payload.data = new Buffer(data.length);\n        data.copy(payload.data);\n    }\n\n    request = new jute.Request(header, payload);\n\n    attempt(\n        self,\n        function (attempts, next) {\n            self.connectionManager.queue(request, function (error, response) {\n                if (error) {\n                    next(error);\n                    return;\n                }\n\n                next(null, response.payload.path);\n            });\n        },\n        callback\n    );\n};\n\n/**\n * Delete a node with the given path. If version is not -1, the request will\n * fail when the provided version does not match the server version.\n *\n * @method delete\n * @param path {String} The node path.\n * @param [version=-1] {Number} The version of the node.\n * @param callback {Function} The callback function.\n */\nClient.prototype.remove = function (path, version, callback) {\n    if (!callback) {\n        callback = version;\n        version = -1;\n    }\n\n    Path.validate(path);\n\n    assert(typeof callback === 'function', 'callback must be a function.');\n    assert(typeof version === 'number', 'version must be a number.');\n\n\n    var self = this,\n        header = new jute.protocol.RequestHeader(),\n        payload = new jute.protocol.DeleteRequest(),\n        request;\n\n    header.type = jute.OP_CODES.DELETE;\n\n    payload.path = path;\n    payload.version = version;\n\n    request = new jute.Request(header, payload);\n\n    attempt(\n        self,\n        function (attempts, next) {\n            self.connectionManager.queue(request, function (error, response) {\n                next(error);\n            });\n        },\n        callback\n    );\n};\n\n/**\n * Set the data for the node of the given path if such a node exists and the\n * optional given version matches the version of the node (if the given\n * version is -1, it matches any node's versions).\n *\n * @method setData\n * @param path {String} The node path.\n * @param data {Buffer} The data buffer.\n * @param [version=-1] {Number} The version of the node.\n * @param callback {Function} The callback function.\n */\nClient.prototype.setData = function (path, data, version, callback) {\n    if (!callback) {\n        callback = version;\n        version = -1;\n    }\n\n    Path.validate(path);\n\n    assert(typeof callback === 'function', 'callback must be a function.');\n    assert(typeof version === 'number', 'version must be a number.');\n\n    assert(\n        data === null || data === undefined || Buffer.isBuffer(data),\n        'data must be a valid buffer, null or undefined.'\n    );\n    if (Buffer.isBuffer(data)) {\n        assert(\n            data.length <= DATA_SIZE_LIMIT,\n            'data must be equal of smaller than ' + DATA_SIZE_LIMIT + ' bytes.'\n        );\n    }\n\n    var self = this,\n        header = new jute.protocol.RequestHeader(),\n        payload = new jute.protocol.SetDataRequest(),\n        request;\n\n    header.type = jute.OP_CODES.SET_DATA;\n\n    payload.path = path;\n    payload.data = new Buffer(data.length);\n    data.copy(payload.data);\n    payload.version = version;\n\n    request = new jute.Request(header, payload);\n\n    attempt(\n        self,\n        function (attempts, next) {\n            self.connectionManager.queue(request, function (error, response) {\n                if (error) {\n                    next(error);\n                    return;\n                }\n\n                next(null, response.payload.stat);\n            });\n        },\n        callback\n    );\n};\n\n/**\n *\n * Retrieve the data and the stat of the node of the given path.\n *\n * If the watcher is provided and the call is successful (no error), a watcher\n * will be left on the node with the given path.\n *\n * The watch will be triggered by a successful operation that sets data on\n * the node, or deletes the node.\n *\n * @method getData\n * @param path {String} The node path.\n * @param [watcher] {Function} The watcher function.\n * @param callback {Function} The callback function.\n */\nClient.prototype.getData = function (path, watcher, callback) {\n    if (!callback) {\n        callback = watcher;\n        watcher = undefined;\n    }\n\n    Path.validate(path);\n\n    assert(typeof callback === 'function', 'callback must be a function.');\n\n    var self = this,\n        header = new jute.protocol.RequestHeader(),\n        payload = new jute.protocol.GetDataRequest(),\n        request;\n\n    header.type = jute.OP_CODES.GET_DATA;\n\n    payload.path = path;\n    payload.watch = (typeof watcher === 'function');\n\n    request = new jute.Request(header, payload);\n\n    attempt(\n        self,\n        function (attempts, next) {\n            self.connectionManager.queue(request, function (error, response) {\n                if (error) {\n                    next(error);\n                    return;\n                }\n\n                if (watcher) {\n                    self.connectionManager.registerDataWatcher(path, watcher);\n                }\n\n                next(null, response.payload.data, response.payload.stat);\n            });\n        },\n        callback\n    );\n};\n\n/**\n * Set the ACL for the node of the given path if such a node exists and the\n * given version matches the version of the node (if the given version is -1,\n * it matches any node's versions).\n *\n *\n * @method setACL\n * @param path {String} The node path.\n * @param acls {Array} The array of ACL objects.\n * @param [version] {Number} The version of the node.\n * @param callback {Function} The callback function.\n */\nClient.prototype.setACL = function (path, acls, version, callback) {\n    if (!callback) {\n        callback = version;\n        version = -1;\n    }\n\n    Path.validate(path);\n    assert(typeof callback === 'function', 'callback must be a function.');\n    assert(\n        Array.isArray(acls) && acls.length > 0,\n        'acls must be a non-empty array.'\n    );\n    assert(typeof version === 'number', 'version must be a number.');\n\n    var self = this,\n        header = new jute.protocol.RequestHeader(),\n        payload = new jute.protocol.SetACLRequest(),\n        request;\n\n    header.type = jute.OP_CODES.SET_ACL;\n\n    payload.path = path;\n    payload.acl = acls.map(function (item) {\n        return item.toRecord();\n    });\n\n    payload.version = version;\n\n    request = new jute.Request(header, payload);\n\n    attempt(\n        self,\n        function (attempts, next) {\n            self.connectionManager.queue(request, function (error, response) {\n                if (error) {\n                    next(error);\n                    return;\n                }\n\n                next(null, response.payload.stat);\n            });\n        },\n        callback\n    );\n};\n\n/**\n * Retrieve the ACL list and the stat of the node of the given path.\n *\n * @method getACL\n * @param path {String} The node path.\n * @param callback {Function} The callback function.\n */\nClient.prototype.getACL = function (path, callback) {\n    Path.validate(path);\n    assert(typeof callback === 'function', 'callback must be a function.');\n\n    var self = this,\n        header = new jute.protocol.RequestHeader(),\n        payload = new jute.protocol.GetACLRequest(),\n        request;\n\n    header.type = jute.OP_CODES.GET_ACL;\n\n    payload.path = path;\n    request = new jute.Request(header, payload);\n\n    attempt(\n        self,\n        function (attempts, next) {\n            self.connectionManager.queue(request, function (error, response) {\n                if (error) {\n                    next(error);\n                    return;\n                }\n\n                var acls;\n\n                if (Array.isArray(response.payload.acl)) {\n                    acls = response.payload.acl.map(function (item) {\n                        return ACL.fromRecord(item);\n                    });\n                }\n\n                next(null, acls, response.payload.stat);\n            });\n        },\n        callback\n    );\n};\n\n/**\n * Check the existence of a node. The callback will be invoked with the\n * stat of the given path, or null if node such node exists.\n *\n * If the watcher function is provided and the call is successful (no error\n * from callback), a watcher will be placed on the node with the given path.\n * The watcher will be triggered by a successful operation that creates/delete\n * the node or sets the data on the node.\n *\n * @method exists\n * @param path {String} The node path.\n * @param [watcher] {Function} The watcher function.\n * @param callback {Function} The callback function.\n */\nClient.prototype.exists = function (path, watcher, callback) {\n    if (!callback) {\n        callback = watcher;\n        watcher = undefined;\n    }\n\n    Path.validate(path);\n    assert(typeof callback === 'function', 'callback must be a function.');\n\n    var self = this,\n        header = new jute.protocol.RequestHeader(),\n        payload = new jute.protocol.ExistsRequest(),\n        request;\n\n    header.type = jute.OP_CODES.EXISTS;\n\n    payload.path = path;\n    payload.watch = (typeof watcher === 'function');\n\n    request = new jute.Request(header, payload);\n\n    attempt(\n        self,\n        function (attempts, next) {\n            self.connectionManager.queue(request, function (error, response) {\n                if (error && error.getCode() !== Exception.NO_NODE) {\n                    next(error);\n                    return;\n                }\n\n                var existence = response.header.err === Exception.OK;\n\n                if (watcher) {\n                    if (existence) {\n                        self.connectionManager.registerDataWatcher(\n                            path,\n                            watcher\n                        );\n                    } else {\n                        self.connectionManager.registerExistenceWatcher(\n                            path,\n                            watcher\n                        );\n                    }\n                }\n\n                next(\n                    null,\n                    existence ? response.payload.stat : null\n                );\n            });\n        },\n        callback\n    );\n};\n\n/**\n * For the given node path, retrieve the children list and the stat.\n *\n * If the watcher callback is provided and the method completes successfully,\n * a watcher will be placed the given node. The watcher will be triggered\n * when an operation successfully deletes the given node or creates/deletes\n * the child under it.\n *\n * @method getChildren\n * @param path {String} The node path.\n * @param [watcher] {Function} The watcher function.\n * @param callback {Function} The callback function.\n */\nClient.prototype.getChildren = function (path, watcher, callback) {\n    if (!callback) {\n        callback = watcher;\n        watcher = undefined;\n    }\n\n    Path.validate(path);\n    assert(typeof callback === 'function', 'callback must be a function.');\n\n    var self = this,\n        header = new jute.protocol.RequestHeader(),\n        payload = new jute.protocol.GetChildren2Request(),\n        request;\n\n    header.type = jute.OP_CODES.GET_CHILDREN2;\n\n    payload.path = path;\n    payload.watch = (typeof watcher === 'function');\n\n    request = new jute.Request(header, payload);\n\n    attempt(\n        self,\n        function (attempts, next) {\n            self.connectionManager.queue(request, function (error, response) {\n                if (error) {\n                    next(error);\n                    return;\n                }\n\n                if (watcher) {\n                    self.connectionManager.registerChildWatcher(path, watcher);\n                }\n\n                next(null, response.payload.children, response.payload.stat);\n            });\n        },\n        callback\n    );\n};\n\n/**\n * Create node path in the similar way of `mkdir -p`\n *\n *\n * @method mkdirp\n * @param path {String} The node path.\n * @param [data=undefined] {Buffer} The data buffer.\n * @param [acls=ACL.OPEN_ACL_UNSAFE] {Array} The array of ACL object.\n * @param [mode=CreateMode.PERSISTENT] {CreateMode} The creation mode.\n * @param callback {Function} The callback function.\n */\nClient.prototype.mkdirp = function (path, data, acls, mode, callback) {\n    var optionalArgs = [data, acls, mode, callback],\n        self = this,\n        currentPath = '',\n        nodes;\n\n    Path.validate(path);\n\n    // Reset arguments so we can reassign correct value to them.\n    data = acls = mode = callback = undefined;\n    optionalArgs.forEach(function (arg, index) {\n        if (Array.isArray(arg)) {\n            acls = arg;\n        } else if (typeof arg === 'number') {\n            mode = arg;\n        } else if (Buffer.isBuffer(arg)) {\n            data = arg;\n        } else if (typeof arg === 'function') {\n            callback = arg;\n        }\n    });\n\n    assert(\n        typeof callback === 'function',\n        'callback must be a function.'\n    );\n\n    acls = Array.isArray(acls) ? acls : ACL.OPEN_ACL_UNSAFE;\n    mode = typeof mode === 'number' ? mode : CreateMode.PERSISTENT;\n\n    assert(\n        data === null || data === undefined || Buffer.isBuffer(data),\n        'data must be a valid buffer, null or undefined.'\n    );\n\n    if (Buffer.isBuffer(data)) {\n        assert(\n            data.length <= DATA_SIZE_LIMIT,\n            'data must be equal of smaller than ' + DATA_SIZE_LIMIT + ' bytes.'\n        );\n    }\n\n    assert(acls.length > 0, 'acls must be a non-empty array.');\n\n    // Remove the empty string\n    nodes = path.split('/').slice(1);\n\n    async.eachSeries(nodes, function (node, next) {\n        currentPath = currentPath + '/' + node;\n        self.create(currentPath, data, acls, mode, function (error, path) {\n            // Skip node exist error.\n            if (error && error.getCode() === Exception.NODE_EXISTS) {\n                next(null);\n                return;\n            }\n\n            next(error);\n        });\n    }, function (error) {\n        callback(error, currentPath);\n    });\n};\n\n/**\n * Create and return a new Transaction instance.\n *\n * @method transaction\n * @return {Transaction} an instance of Transaction.\n */\nClient.prototype.transaction = function () {\n    return new Transaction(this.connectionManager);\n};\n\n/**\n * Create a new ZooKeeper client.\n *\n * @method createClient\n * @for node-zookeeper-client\n */\nfunction createClient(connectionString, options) {\n    return new Client(connectionString, options);\n}\n\nexports.createClient = createClient;\nexports.ACL = ACL;\nexports.Id = Id;\nexports.Permission = Permission;\nexports.CreateMode = CreateMode;\nexports.State = State;\nexports.Event = Event;\nexports.Exception = Exception;\n","/home/travis/build/npmtest/node-npmtest-node-zookeeper-client/node_modules/node-zookeeper-client/lib/jute/index.js":"/**\n * Copyright (c) 2013 Yahoo! Inc. All rights reserved.\n *\n * Copyrights licensed under the MIT License. See the accompanying LICENSE file\n * for terms.\n */\n\n/**\n * Automatically generate all ZooKeeper related protocol classes.\n *\n * @module zookeeper.jute\n */\n\nvar fs = require('fs');\nvar util = require('util');\nvar assert = require('assert');\n\nvar exports = module.exports;\nvar jute = exports;\n\n// Constants.\nvar SPECIFICATION_FILE = './specification.json';\nvar PROTOCOL_VERSION = 0;\n\nvar OP_CODES = {\n    NOTIFICATION : 0,\n    CREATE : 1,\n    DELETE : 2,\n    EXISTS : 3,\n    GET_DATA : 4,\n    SET_DATA : 5,\n    GET_ACL : 6,\n    SET_ACL : 7,\n    GET_CHILDREN : 8,\n    SYNC : 9,\n    PING : 11,\n    GET_CHILDREN2 : 12,\n    CHECK : 13,\n    MULTI : 14,\n    AUTH : 100,\n    SET_WATCHES : 101,\n    SASL : 102,\n    CREATE_SESSION : -10,\n    CLOSE_SESSION : -11,\n    ERROR : -1\n};\n\nvar XID_NOTIFICATION = -1;\nvar XID_PING = -2;\nvar XID_AUTHENTICATION = -4;\nvar XID_SET_WATCHES = -8;\n\n/**\n * The prototype class for all Zookeeper jute protocol classes.\n *\n * // TODO: Move it out\n *\n * @class Record\n * @constructor\n * @param specification {Array} The array of record attribute specification.\n * @param args {Array} The constructor array of the Record class.\n */\nfunction Record(specification, args) {\n    if (!Array.isArray(specification)) {\n        throw new Error('specification must be a valid Array.');\n    }\n\n    this.specification = specification;\n    this.chrootPath = undefined;\n\n    args = args || [];\n\n    var self = this,\n        match;\n\n    self.specification.forEach(function (attribute, index) {\n        switch (attribute.type) {\n        case 'int':\n            if (typeof args[index] === 'number') {\n                self[attribute.name] = args[index];\n            } else {\n                self[attribute.name] = 0;\n            }\n            break;\n        case 'long':\n            // Long is represented by a buffer of 8 bytes in big endian since\n            // Javascript does not support native 64 integer.\n            self[attribute.name] = new Buffer(8);\n\n            if (Buffer.isBuffer(args[index])) {\n                args[index].copy(self[attribute.name]);\n            } else {\n                self[attribute.name].fill(0);\n            }\n            break;\n        case 'buffer':\n            if (Buffer.isBuffer(args[index])) {\n                self[attribute.name] = new Buffer(args[index].length);\n                args[index].copy(self[attribute.name]);\n            } else {\n                self[attribute.name] = undefined;\n            }\n            break;\n        case 'ustring':\n            if (typeof args[index] === 'string') {\n                self[attribute.name] = args[index];\n            } else {\n                self[attribute.name] = undefined;\n            }\n            break;\n        case 'boolean':\n            if (typeof args[index] === 'boolean') {\n                self[attribute.name] = args[index];\n            } else {\n                self[attribute.name] = false;\n            }\n            break;\n        default:\n            if ((match = /^vector<([\\w.]+)>$/.exec(attribute.type)) !== null) {\n                if (Array.isArray(args[index])) {\n                    self[attribute.name] = args[index];\n                } else {\n                    self[attribute.name] = undefined;\n                }\n            } else if ((match = /^data\\.(\\w+)$/.exec(attribute.type)) !== null) {\n                if (args[index] instanceof Record) {\n                    self[attribute.name] = args[index];\n                } else {\n                    self[attribute.name] = new jute.data[match[1]]();\n                }\n            } else {\n                throw new Error('Unknown type: ' + attribute.type);\n            }\n        }\n    });\n}\n\nRecord.prototype.setChrootPath = function (path) {\n    this.chrootPath = path;\n};\n\nfunction byteLength(type, value) {\n    var size = 0,\n        match;\n\n    switch (type) {\n    case 'int':\n        size = 4;\n        break;\n    case 'long':\n        size = 8;\n        break;\n    case 'buffer':\n        // buffer length + buffer content\n        size = 4;\n        if (Buffer.isBuffer(value)) {\n            size += value.length;\n        }\n        break;\n    case 'ustring':\n        // string buffer length + content\n        size = 4;\n        if (typeof value === 'string') {\n            size += Buffer.byteLength(value);\n        }\n        break;\n    case 'boolean':\n        size = 1;\n        break;\n    default:\n        if ((match = /^vector<([\\w.]+)>$/.exec(type)) !== null) {\n            // vector size + vector content\n            size = 4;\n            if (Array.isArray(value)) {\n                value.forEach(function (item) {\n                    size += byteLength(match[1], item);\n                });\n            }\n        } else if ((match = /^data\\.(\\w+)$/.exec(type)) !== null) {\n            size = value.byteLength();\n        } else {\n            throw new Error('Unknown type: ' + type);\n        }\n    }\n\n    return size;\n}\n\nfunction prependChroot(self, path) {\n    if (!self.chrootPath) {\n        return path;\n    }\n\n    if (path === '/') {\n        return self.chrootPath;\n    }\n\n    return self.chrootPath + path;\n}\n\n/**\n * Calculate and return the size of the buffer which is need to serialize this\n * record.\n *\n * @method byteLength\n * @return {Number} The number of bytes.\n */\nRecord.prototype.byteLength = function () {\n    var self = this,\n        size = 0;\n\n    self.specification.forEach(function (attribute) {\n        var value = self[attribute.name];\n\n        // Add the chroot path to calculate the real path.\n        if (attribute.name === 'path') {\n            value = prependChroot(self, value);\n        }\n\n        if ((attribute.name === 'dataWatches' ||\n             attribute.name === 'existWatches' ||\n             attribute.name === 'childWatches') &&\n                 Array.isArray(value)) {\n\n            value = value.map(function (path) {\n                return prependChroot(self, path);\n            });\n        }\n\n        size += byteLength(attribute.type, value);\n    });\n\n    return size;\n};\n\nfunction serialize(type, value, buffer, offset) {\n    var bytesWritten = 0,\n        length = 0,\n        match;\n\n    switch (type) {\n    case 'int':\n        buffer.writeInt32BE(value, offset);\n        bytesWritten = 4;\n        break;\n    case 'long':\n        // Long is represented by a buffer of 8 bytes in big endian since\n        // Javascript does not support native 64 integer.\n        value.copy(buffer, offset);\n        bytesWritten = 8;\n        break;\n    case 'buffer':\n        if (Buffer.isBuffer(value)) {\n            buffer.writeInt32BE(value.length, offset);\n            bytesWritten = 4;\n\n            value.copy(buffer, offset + bytesWritten);\n            bytesWritten += value.length;\n        } else {\n            buffer.writeInt32BE(-1, offset);\n            bytesWritten = 4;\n        }\n        break;\n    case 'ustring':\n        if (typeof value === 'string') {\n            length = Buffer.byteLength(value);\n            buffer.writeInt32BE(length, offset);\n            bytesWritten = 4;\n\n            new Buffer(value).copy(buffer, offset + bytesWritten);\n            bytesWritten += length;\n        } else {\n            buffer.writeInt32BE(-1, offset);\n            bytesWritten += 4;\n        }\n        break;\n    case 'boolean':\n        buffer.writeUInt8(value ? 1 : 0, offset);\n        bytesWritten += 1;\n        break;\n    default:\n        if ((match = /^vector<([\\w.]+)>$/.exec(type)) !== null) {\n            // vector size + vector content\n            if (Array.isArray(value)) {\n                buffer.writeInt32BE(value.length, offset);\n                bytesWritten += 4;\n\n                value.forEach(function (item) {\n                    bytesWritten += serialize(\n                        match[1],\n                        item,\n                        buffer,\n                        offset + bytesWritten\n                    );\n                });\n            } else {\n                buffer.writeInt32BE(-1, offset);\n                bytesWritten += 4;\n            }\n        } else if ((match = /^data\\.(\\w+)$/.exec(type)) !== null) {\n            bytesWritten += value.serialize(buffer, offset + bytesWritten);\n        } else {\n            throw new Error('Unknown type: ' + type);\n        }\n    }\n\n    return bytesWritten;\n}\n\n\n/**\n * Serialize the record content to a buffer.\n *\n * @method serialize\n * @param buffer {Buffer} A buffer object.\n * @param offset {Number} The offset where the write starts.\n * @return {Number} The number of bytes written.\n */\nRecord.prototype.serialize = function (buffer, offset) {\n    if (!Buffer.isBuffer(buffer)) {\n        throw new Error('buffer must an instance of Node.js Buffer class.');\n    }\n\n    if (offset < 0 || offset >= buffer.length) {\n        throw new Error('offset: ' + offset + ' is out of buffer range.');\n    }\n\n    var self = this,\n        size = this.byteLength();\n\n    if (offset + size > buffer.length) {\n        throw new Error('buffer does not have enough space.');\n    }\n\n    self.specification.forEach(function (attribute) {\n        var value = self[attribute.name];\n\n        // Add the chroot path to generate the real path.\n        if (attribute.name === 'path') {\n            value = prependChroot(self, value);\n        }\n\n        if ((attribute.name === 'dataWatches' ||\n             attribute.name === 'existWatches' ||\n             attribute.name === 'childWatches') &&\n                 Array.isArray(value)) {\n\n            value = value.map(function (path) {\n                return prependChroot(self, path);\n            });\n        }\n\n        offset += serialize(\n            attribute.type,\n            value,\n            buffer,\n            offset\n        );\n    });\n\n    return size;\n};\n\nfunction deserialize(type, buffer, offset) {\n    var bytesRead = 0,\n        length = 0,\n        match,\n        value,\n        result;\n\n    switch (type) {\n    case 'int':\n        value = buffer.readInt32BE(offset);\n        bytesRead = 4;\n        break;\n    case 'long':\n        // Long is represented by a buffer of 8 bytes in big endian since\n        // Javascript does not support native 64 integer.\n        value = new Buffer(8);\n        buffer.copy(value, 0, offset, offset + 8);\n        bytesRead = 8;\n        break;\n    case 'buffer':\n        length = buffer.readInt32BE(offset);\n        bytesRead = 4;\n\n        if (length === -1) {\n            value = undefined;\n        } else {\n            value = new Buffer(length);\n            buffer.copy(\n                value,\n                0,\n                offset + bytesRead,\n                offset + bytesRead + length\n            );\n\n            bytesRead += length;\n        }\n        break;\n    case 'ustring':\n        length = buffer.readInt32BE(offset);\n        bytesRead = 4;\n\n        if (length === -1) {\n            value = undefined;\n        } else {\n            value = buffer.toString(\n                'utf8',\n                offset + bytesRead,\n                offset + bytesRead + length\n            );\n\n            bytesRead += length;\n        }\n        break;\n    case 'boolean':\n        value = buffer.readUInt8(offset) === 1 ? true : false;\n        bytesRead = 1;\n        break;\n    default:\n        if ((match = /^vector<([\\w.]+)>$/.exec(type)) !== null) {\n            length = buffer.readInt32BE(offset);\n            bytesRead = 4;\n\n            if (length === -1) {\n                value = undefined;\n            } else {\n                value = [];\n                while (length > 0) {\n                    result = deserialize(match[1], buffer, offset + bytesRead);\n                    value.push(result.value);\n                    bytesRead += result.bytesRead;\n                    length -= 1;\n                }\n            }\n        } else if ((match = /^data\\.(\\w+)$/.exec(type)) !== null) {\n            value = new jute.data[match[1]]();\n            bytesRead = value.deserialize(buffer, offset);\n        } else {\n            throw new Error('Unknown type: ' + type);\n        }\n    }\n\n    return {\n        value : value,\n        bytesRead : bytesRead\n    };\n}\n\n/**\n * De-serialize the record content from a buffer.\n *\n * @method deserialize\n * @param buffer {Buffer} A buffer object.\n * @param offset {Number} The offset where the read starts.\n * @return {Number} The number of bytes read.\n */\nRecord.prototype.deserialize = function (buffer, offset) {\n    if (!Buffer.isBuffer(buffer)) {\n        throw new Error('buffer must an instance of Node.js Buffer class.');\n    }\n\n    if (offset < 0 || offset >= buffer.length) {\n        throw new Error('offset: ' + offset + ' is out of buffer range.');\n    }\n\n    var self = this,\n        bytesRead = 0,\n        result;\n\n    self.specification.forEach(function (attribute) {\n        result = deserialize(attribute.type, buffer, offset + bytesRead);\n        self[attribute.name] = result.value;\n        bytesRead += result.bytesRead;\n\n        // Remove the chroot part from the real path.\n        if (self.chrootPath && attribute.name === 'path') {\n            if (self.path === self.chrootPath) {\n                self.path = '/';\n            } else {\n                self.path = self.path.substring(self.chrootPath.length);\n            }\n        }\n    });\n\n    return bytesRead;\n};\n\n\nfunction TransactionRequest(ops) {\n    if (!(this instanceof TransactionRequest)) {\n        return new TransactionRequest(ops);\n    }\n\n    assert(Array.isArray(ops), 'ops must be a valid array.');\n    this.ops = ops;\n    this.records = [];\n\n    this.ops.forEach(function (op) {\n        var mh = new jute.protocol.MultiHeader(op.type, false, -1),\n            record;\n\n        this.records.push(mh);\n\n        switch (op.type) {\n        case jute.OP_CODES.CREATE:\n            record = new jute.protocol.CreateRequest();\n            record.path = op.path;\n            record.data = op.data;\n            record.acl = op.acls.map(function (item) {\n                return item.toRecord();\n            });\n            record.flags = op.mode;\n            break;\n        case jute.OP_CODES.DELETE:\n            record = new jute.protocol.DeleteRequest();\n            record.path = op.path;\n            record.version = op.version;\n            break;\n        case jute.OP_CODES.SET_DATA:\n            record = new jute.protocol.SetDataRequest();\n            record.path = op.path;\n            if (Buffer.isBuffer(op.data)) {\n                record.data = new Buffer(op.data.length);\n                op.data.copy(record.data);\n            }\n            record.version = op.version;\n            break;\n        case jute.OP_CODES.CHECK:\n            record = new jute.protocol.CheckVersionRequest();\n            record.path = op.path;\n            record.version = op.version;\n            break;\n        default:\n            throw new Error('Unknown op type: ' +  op.type);\n        }\n\n        this.records.push(record);\n    }, this);\n\n    // Signal the end of the ops.\n    this.records.push(new jute.protocol.MultiHeader(-1, true, -1));\n}\n\nTransactionRequest.prototype.setChrootPath = function (path) {\n    this.records.forEach(function (record) {\n        record.setChrootPath(path);\n    });\n};\n\n\nTransactionRequest.prototype.byteLength = function () {\n    return this.records.reduce(function (length, record) {\n        return length + record.byteLength();\n    }, 0);\n};\n\nTransactionRequest.prototype.serialize = function (buffer, offset) {\n    assert(\n        Buffer.isBuffer(buffer),\n        'buffer must an instance of Node.js Buffer class.'\n    );\n\n    assert(\n        offset >= 0 && offset < buffer.length,\n        'offset: ' + offset + ' is out of buffer range.'\n    );\n\n    var size = this.byteLength();\n\n    if (offset + size > buffer.length) {\n        throw new Error('buffer does not have enough space.');\n    }\n\n    this.records.forEach(function (record) {\n        offset += record.serialize(\n            buffer,\n            offset\n        );\n    });\n\n    return size;\n};\n\nfunction TransactionResponse() {\n    if (!(this instanceof TransactionResponse)) {\n        return new TransactionResponse();\n    }\n\n    this.results = [];\n    this.chrootPath = undefined;\n}\n\nTransactionResponse.prototype.setChrootPath = function (path) {\n    this.chrootPath = path;\n};\n\nTransactionResponse.prototype.deserialize = function (buffer, offset) {\n    assert(\n        Buffer.isBuffer(buffer),\n        'buffer must an instance of Node.js Buffer class.'\n    );\n\n    assert(\n        offset >= 0 && offset < buffer.length,\n        'offset: ' + offset + ' is out of buffer range.'\n    );\n\n    var self = this,\n        bytesRead = 0,\n        header,\n        response;\n\n    while (true) {\n        header = new jute.protocol.MultiHeader();\n        bytesRead += header.deserialize(buffer, offset + bytesRead);\n\n        if (header.done) {\n            break;\n        }\n\n        switch (header.type) {\n        case jute.OP_CODES.CREATE:\n            response = new jute.protocol.CreateResponse();\n            response.setChrootPath(self.chrootPath);\n            bytesRead += response.deserialize(buffer, offset + bytesRead);\n            self.results.push({\n                type : header.type,\n                path : response.path\n            });\n            break;\n        case jute.OP_CODES.DELETE:\n            self.results.push({\n                type : header.type\n            });\n            break;\n        case jute.OP_CODES.SET_DATA:\n            response = new jute.protocol.SetDataResponse();\n            response.setChrootPath(self.chrootPath);\n            bytesRead += response.deserialize(buffer, offset + bytesRead);\n            self.results.push({\n                type : header.type,\n                stat : response.stat\n            });\n            break;\n        case jute.OP_CODES.CHECK:\n            self.results.push({\n                type : header.type\n            });\n            break;\n        case jute.OP_CODES.ERROR:\n            response = new jute.protocol.ErrorResponse();\n            response.setChrootPath(self.chrootPath);\n            bytesRead += response.deserialize(buffer, offset + bytesRead);\n            self.results.push({\n                type : header.type,\n                err : response.err\n            });\n            break;\n        default:\n            throw new Error(\n                'Unknown type: ' + header.type + ' in transaction response.'\n            );\n        }\n    }\n\n    return bytesRead;\n};\n\n\n\n/**\n * This class represent the request the client sends over the wire to ZooKeeper\n * server.\n *\n * @class Request\n * @constructor\n * @param header {Record} The request header record.\n * @param payload {payload} The request payload record.\n */\nfunction Request(header, payload) {\n    this.header = header;\n    this.payload = payload;\n}\n\n/**\n * Serialize the request to a buffer.\n * @method toBuffer\n * @return {Buffer} The buffer which contains the serialized request.\n */\nRequest.prototype.toBuffer = function () {\n    var size = 0,\n        offset = 0,\n        buffer;\n\n    if (this.header) {\n        size += this.header.byteLength();\n    }\n\n    if (this.payload) {\n        size += this.payload.byteLength();\n    }\n\n    // Needs 4 extra for the length field (Int32)\n    buffer = new Buffer(size + 4);\n\n    buffer.writeInt32BE(size, offset);\n    offset += 4;\n\n    if (this.header) {\n        offset += this.header.serialize(buffer, offset);\n    }\n\n    if (this.payload) {\n        offset += this.payload.serialize(buffer, offset);\n    }\n\n    return buffer;\n};\n\n/**\n * This class represent the response that ZooKeeper sends back to the client.\n *\n * @class Responsee\n * @constructor\n * @param header {Record} The request header record.\n * @param payload {payload} The request payload record.\n */\nfunction Response(header, payload) {\n    this.header = header;\n    this.payload = payload;\n}\n\n/**\n * Generate a Protocol class according to the specification.\n * @for module.jute\n * @method generateClass\n */\nfunction generateClass(specification, moduleName, className) {\n    var spec = specification[moduleName][className],\n        constructor;\n\n    constructor = function () {\n        Record.call(this, spec, Array.prototype.slice.call(arguments, 0));\n    };\n\n    util.inherits(constructor, Record);\n\n    return constructor;\n}\n\n\n// Exports constants\nexports.PROTOCOL_VERSION = PROTOCOL_VERSION;\nexports.OP_CODES = OP_CODES;\n\nexports.XID_NOTIFICATION = XID_NOTIFICATION;\nexports.XID_PING = XID_PING;\nexports.XID_AUTHENTICATION = XID_AUTHENTICATION;\n\n// Exports classes\nexports.Request = Request;\nexports.Response = Response;\n\n// TODO: Consider move to protocol namespace\nexports.TransactionRequest = TransactionRequest;\nexports.TransactionResponse = TransactionResponse;\n\n// Automatically generates and exports all protocol and data classes.\nvar specification = require(SPECIFICATION_FILE);\n\nObject.keys(specification).forEach(function (moduleName) {\n    // Modules like protocol or data.\n    exports[moduleName] = exports[moduleName] || {};\n\n    Object.keys(specification[moduleName]).forEach(function (className) {\n        exports[moduleName][className] =\n            generateClass(specification, moduleName, className);\n    });\n});\n\n\n\n","/home/travis/build/npmtest/node-npmtest-node-zookeeper-client/node_modules/node-zookeeper-client/lib/ACL.js":"/**\n * Copyright (c) 2013 Yahoo! Inc. All rights reserved.\n *\n * Copyrights licensed under the MIT License. See the accompanying LICENSE file\n * for terms.\n */\n\n\nvar jute = require('./jute');\nvar Id = require('./Id.js');\nvar Permission = require('./Permission.js');\n\nfunction ACL(permission, id) {\n    if (typeof permission !== 'number' || permission < 1 || permission > 31) {\n        throw new Error('permission must be a valid integer.');\n    }\n\n    if (!(id instanceof Id)) {\n        throw new Error('id must be an instance of Id class.');\n    }\n\n    this.permission = permission;\n    this.id = id;\n}\n\nACL.prototype.toRecord = function () {\n    return new jute.data.ACL(\n        this.permission,\n        this.id.toRecord()\n    );\n};\n\nvar ACLS = {\n    OPEN_ACL_UNSAFE : [new ACL(Permission.ALL, Id.ANYONE_ID_UNSAFE)],\n    CREATOR_ALL_ACL : [new ACL(Permission.ALL, Id.AUTH_IDS)],\n    READ_ACL_UNSAFE : [new ACL(Permission.READ, Id.ANYONE_ID_UNSAFE)]\n};\n\n\nfunction fromRecord(record) {\n    if (!(record instanceof jute.data.ACL)) {\n        throw new Error('record must be an instace of jute.data.ACL.');\n    }\n\n    return new ACL(record.perms, Id.fromRecord(record.id));\n}\n\n\nmodule.exports = ACL;\nmodule.exports.fromRecord = fromRecord;\nObject.keys(ACLS).forEach(function (key) {\n    module.exports[key] = ACLS[key];\n});\n\n","/home/travis/build/npmtest/node-npmtest-node-zookeeper-client/node_modules/node-zookeeper-client/lib/Id.js":"/**\n * Copyright (c) 2013 Yahoo! Inc. All rights reserved.\n *\n * Copyrights licensed under the MIT License. See the accompanying LICENSE file\n * for terms.\n */\n\n\nvar jute = require('./jute');\n\nfunction Id(scheme, id) {\n    if (!scheme || typeof scheme !== 'string') {\n        throw new Error('scheme must be a non-empty string.');\n    }\n\n    if (typeof id !== 'string') {\n        throw new Error('id must be a string.');\n    }\n\n    this.scheme = scheme;\n    this.id = id;\n}\n\nId.prototype.toRecord = function () {\n    return new jute.data.Id(\n        this.scheme,\n        this.id\n    );\n};\n\nvar IDS = {\n    ANYONE_ID_UNSAFE : new Id('world', 'anyone'),\n    AUTH_IDS : new Id('auth', '')\n};\n\n\nfunction fromRecord(record) {\n    if (!(record instanceof jute.data.Id)) {\n        throw new Error('record must be an instace of jute.data.Id.');\n    }\n\n    return new Id(record.scheme, record.id);\n}\n\nmodule.exports = Id;\nmodule.exports.fromRecord = fromRecord;\nObject.keys(IDS).forEach(function (key) {\n    module.exports[key] = IDS[key];\n});\n\n\n","/home/travis/build/npmtest/node-npmtest-node-zookeeper-client/node_modules/node-zookeeper-client/lib/Permission.js":"/**\n * Copyright (c) 2013 Yahoo! Inc. All rights reserved.\n *\n * Copyrights licensed under the MIT License. See the accompanying LICENSE file\n * for terms.\n */\n\n\n\nvar PERMISSIONS = {\n    READ : 1,\n    WRITE : 2,\n    CREATE : 4,\n    DELETE : 8,\n    ADMIN : 16,\n    ALL : 31\n};\n\nmodule.exports = PERMISSIONS;\n\n","/home/travis/build/npmtest/node-npmtest-node-zookeeper-client/node_modules/node-zookeeper-client/lib/Path.js":"/**\n * Copyright (c) 2013 Yahoo! Inc. All rights reserved.\n *\n * Copyrights licensed under the MIT License. See the accompanying LICENSE file\n * for terms.\n */\n\n\nvar assert = require('assert');\n\n/**\n * Valiadate the given node path, throw out an instance of AssertionError if\n * the path is not valid.\n *\n * @method validate\n * @param path {String} The path of a node.\n */\nfunction validate(path) {\n    assert(\n        path && typeof path === 'string',\n        'Node path must be a non-empty string.'\n    );\n\n    assert(path[0] === '/', 'Node path must start with / character.');\n\n    // Shortcut, no need to check more since the path is the root.\n    if (path.length === 1) {\n        return;\n    }\n\n    assert(\n        path[path.length - 1] !== '/',\n        'Node path must not end with / character.'\n    );\n\n    assert(\n        !/\\/\\//.test(path),\n        'Node path must not contain empty node name.'\n    );\n\n    assert(\n        !/\\/\\.(\\.)?(\\/|$)/.test(path),\n        'Node path must not contain relative path(s).'\n    );\n\n    // TODO filter out special characters\n}\n\nexports.validate = validate;\n","/home/travis/build/npmtest/node-npmtest-node-zookeeper-client/node_modules/node-zookeeper-client/lib/Event.js":"/**\n * Copyright (c) 2013 Yahoo! Inc. All rights reserved.\n *\n * Copyrights licensed under the MIT License. See the accompanying LICENSE file\n * for terms.\n */\n\nvar assert = require('assert');\n\n// Event types\nvar TYPES = {\n    NODE_CREATED : 1,\n    NODE_DELETED : 2,\n    NODE_DATA_CHANGED : 3,\n    NODE_CHILDREN_CHANGED : 4\n};\n\n/**\n * Check if the given event type code is defined or not, throw an error if the\n * type is not defined.\n *\n * @method validateType\n * @param type {Number} The type.\n */\nfunction validateType(type) {\n    assert(typeof type === 'number', 'type must be a number.');\n\n    var defined = Object.keys(TYPES).some(function (name) {\n        return TYPES[name] === type;\n    });\n\n    if (!defined) {\n        throw new Error('Unknown type: ' + type);\n    }\n}\n/**\n * Watcher event.\n *\n * @class Event\n * @constructor\n * @private\n * @param type {Number} The type of the event.\n * @param name {String} The name of the event.\n * @param [path] {String} The node path of the event.\n */\nfunction Event(type, name, path) {\n    validateType(type);\n    assert(\n        name && typeof name === 'string',\n        'name must be a non-empty string.'\n    );\n\n    this.type = type;\n    this.name = name;\n    this.path = path;\n}\n\n/**\n * Return the type of the event.\n *\n * @method getType\n * @return {String} The name.\n */\nEvent.prototype.getType = function () {\n    return this.type;\n};\n\n/**\n * Return the name of the event.\n *\n * @method getName\n * @return {String} The name.\n */\nEvent.prototype.getName = function () {\n    return this.name;\n};\n\n/**\n * Return the path of the event.\n *\n * @method getPath\n * @return {String} The path.\n */\nEvent.prototype.getPath = function () {\n    return this.path;\n};\n\n/**\n * Return a string representation of the event.\n *\n * @method toString\n * @return {String} The string representation.\n */\nEvent.prototype.toString = function () {\n    var result = this.name + '[' + this.type + ']';\n\n    if (this.path) {\n        result += '@' + this.path;\n    }\n\n    return result;\n};\n\n/**\n * Factory method to crate an instance of event from an instance of\n * jute.WatcherEvent.\n *\n * @method create\n * @param watcherEvent {WatcherEvent} an instance of jute.WatcherEvent\n */\nfunction create(watcherEvent) {\n    assert(watcherEvent, 'watcherEvent must be a valid object.');\n    validateType(watcherEvent.type);\n\n    var name,\n        i = 0,\n        keys = Object.keys(TYPES);\n\n    while (i < keys.length) {\n        if (TYPES[keys[i]] === watcherEvent.type) {\n            name = keys[i];\n            break;\n        }\n\n        i += 1;\n    }\n\n    return new Event(watcherEvent.type, name, watcherEvent.path);\n}\n\nmodule.exports = Event;\nmodule.exports.create = create;\nObject.keys(TYPES).forEach(function (key) {\n    module.exports[key] = TYPES[key];\n});\n","/home/travis/build/npmtest/node-npmtest-node-zookeeper-client/node_modules/node-zookeeper-client/lib/State.js":"/**\n * Copyright (c) 2013 Yahoo! Inc. All rights reserved.\n *\n * Copyrights licensed under the MIT License. See the accompanying LICENSE file\n * for terms.\n */\n\n\nvar assert = require('assert');\n\n/**\n * ZooKeeper client state class.\n *\n * @class State\n * @constructor\n * @private\n * @param name {String} The name of the state.\n * @param code {Number} The code of the state.\n */\nfunction State(name, code) {\n    assert(\n        name && typeof name === 'string',\n        'name must be a non-empty string.'\n    );\n    assert(typeof code === 'number', 'type must be a number.');\n\n    this.name = name;\n    this.code = code;\n}\n\n/**\n * Return the name of the state.\n * @method getName\n * @return {String} The name o fhte state.\n */\nState.prototype.getName = function () {\n    return this.name;\n};\n\n/**\n * Return the code of the state.\n * @method getCode\n * @return {Number} The code of the state.\n */\nState.prototype.getCode = function () {\n    return this.code;\n};\n\n/**\n * Return a string representation of the state.\n *\n * @method toString\n * @return {String} The string representation of the state.\n */\nState.prototype.toString = function () {\n    return this.name + '[' + this.code + ']';\n};\n\n// Exported state constants\nvar STATES = {\n    DISCONNECTED : new State('DISCONNECTED', 0),\n    SYNC_CONNECTED : new State('SYNC_CONNECTED', 3),\n    AUTH_FAILED : new State('AUTH_FAILED', 4),\n    CONNECTED_READ_ONLY : new State('CONNECTED_READ_ONLY', 5),\n    SASL_AUTHENTICATED : new State('SASL_AUTHENTICATED', 6),\n    EXPIRED : new State('EXPIRED', -122)\n};\n\nmodule.exports = STATES;\n","/home/travis/build/npmtest/node-npmtest-node-zookeeper-client/node_modules/node-zookeeper-client/lib/CreateMode.js":"/**\n * Copyright (c) 2013 Yahoo! Inc. All rights reserved.\n *\n * Copyrights licensed under the MIT License. See the accompanying LICENSE file\n * for terms.\n */\n\nvar CREATE_MODES = {\n    /**\n     * The znode will not be automatically deleted upon client's disconnect.\n     */\n    PERSISTENT : 0,\n\n    /**\n    * The znode will not be automatically deleted upon client's disconnect,\n    * and its name will be appended with a monotonically increasing number.\n    */\n    PERSISTENT_SEQUENTIAL : 2,\n\n    /**\n     * The znode will be deleted upon the client's disconnect.\n     */\n    EPHEMERAL : 1,\n\n    /**\n     * The znode will be deleted upon the client's disconnect, and its name\n     * will be appended with a monotonically increasing number.\n     */\n    EPHEMERAL_SEQUENTIAL : 3\n};\n\nmodule.exports = CREATE_MODES;\n","/home/travis/build/npmtest/node-npmtest-node-zookeeper-client/node_modules/node-zookeeper-client/lib/Exception.js":"/**\n * Copyright (c) 2013 Yahoo! Inc. All rights reserved.\n *\n * Copyrights licensed under the MIT License. See the accompanying LICENSE file\n * for terms.\n */\n\n\nvar util   = require('util');\nvar assert = require('assert');\n\n// All error codes.\nvar CODES = {\n    OK : 0,\n    SYSTEM_ERROR : -1,\n    RUNTIME_INCONSISTENCY : -2,\n    DATA_INCONSISTENCY : -3,\n    CONNECTION_LOSS : -4,\n    MARSHALLING_ERROR : -5,\n    UNIMPLEMENTED : -6,\n    OPERATION_TIMEOUT : -7,\n    BAD_ARGUMENTS : -8,\n    API_ERROR : -100,\n    NO_NODE : -101,\n    NO_AUTH : -102,\n    BAD_VERSION : -103,\n    NO_CHILDREN_FOR_EPHEMERALS : -108,\n    NODE_EXISTS : -110,\n    NOT_EMPTY : -111,\n    SESSION_EXPIRED : -112,\n    INVALID_CALLBACK : -113,\n    INVALID_ACL : -114,\n    AUTH_FAILED : -115\n};\n\n/**\n * Check if the given error code is a valid code, throw an error if the\n * code is not supported.\n *\n * @method validateCode\n * @param code {Number} The error code to be checked.\n */\nfunction validateCode(code) {\n    assert(typeof code === 'number', 'code must be a number.');\n\n    var defined = Object.keys(CODES).some(function (name) {\n        return CODES[name] === code;\n    });\n\n    if (!defined) {\n        throw new Error('Unknown code: ' + code);\n    }\n}\n\n/**\n * Exception class for all zookeeper errors.\n *\n * @class Exception\n * @constructor\n * @private\n * @param code {Number} Exception code.\n * @param name {String} Name of the exception.\n * @param path {String} Node path of the exception, optional.\n * @param ctor {String} The function to start in stack trace.\n */\nfunction Exception(code, name, path, ctor) {\n    if (!ctor) {\n        ctor = path;\n        path = undefined;\n    }\n\n    validateCode(code);\n    assert(\n        name && typeof name === 'string',\n        'name must be a non-empty string.'\n    );\n    assert(typeof ctor === 'function', 'ctor must be a function.');\n\n    Error.captureStackTrace(this, ctor || Exception);\n    this.code = code;\n    this.name = name;\n    this.path = path;\n\n    this.message = 'Exception: ' + name + '[' + code + ']';\n\n    if (path) {\n        this.message += '@' + path;\n    }\n}\n\nutil.inherits(Exception, Error);\n\n/**\n * Return the code of the Exception.\n *\n * @method getCode\n * @return {Number} The code.\n */\nException.prototype.getCode = function () {\n    return this.code;\n};\n\n/**\n * Return the name of the Exception.\n *\n * @method getName\n * @return {String} The name.\n */\nException.prototype.getName = function () {\n    return this.name;\n};\n\n/**\n * Return the path of the Exception.\n *\n * @method getPath\n * @return {String} The path.\n */\nException.prototype.getPath = function () {\n    return this.path;\n};\n\n/**\n *\n * @method toString\n * @return {String} The readable form of the exception.\n */\nException.prototype.toString = function () {\n    return this.message;\n};\n\n/**\n * The factory method to create an instance of Exception.\n *\n * @method create\n * @param code {Number} Exception code.\n * @param path {String} Node path of the exception, optional.\n */\nfunction create(code, path) {\n    validateCode(code);\n\n    var name,\n        i = 0,\n        keys = Object.keys(CODES);\n\n    while (i < keys.length) {\n        if (CODES[keys[i]] === code) {\n            name = keys[i];\n            break;\n        }\n\n        i += 1;\n    }\n\n    return new Exception(code, name, path, create);\n}\n\nmodule.exports = Exception;\nmodule.exports.create = create;\n\n/**\n * Expose all the error codes.\n */\nObject.keys(CODES).forEach(function (key) {\n    module.exports[key] = CODES[key];\n});\n\n","/home/travis/build/npmtest/node-npmtest-node-zookeeper-client/node_modules/node-zookeeper-client/lib/Transaction.js":"/**\n * Copyright (c) 2013 Yahoo! Inc. All rights reserved.\n *\n * Copyrights licensed under the MIT License. See the accompanying LICENSE file\n * for terms.\n */\n\n\nvar assert            = require('assert');\nvar jute              = require('./jute');\nvar Path              = require('./Path.js');\nvar ACL               = require('./ACL.js');\nvar Exception         = require('./Exception.js');\nvar CreateMode        = require('./CreateMode.js');\nvar ConnectionManager = require('./ConnectionManager.js');\n\n/**\n * Transaction provides a builder interface that helps building an atomic set\n * of operations.\n *\n * @class Transaction\n * @constructor\n * @param connectionManager {ConnectionManager} an instance of ConnectionManager.\n */\nfunction Transaction(connectionManager) {\n    if (!(this instanceof Transaction)) {\n        return new Transaction(connectionManager);\n    }\n\n    assert(\n        connectionManager instanceof ConnectionManager,\n        'connectionManager must be an instance of ConnectionManager.'\n    );\n\n    this.ops = [];\n    this.connectionManager = connectionManager;\n}\n\n/**\n * Add a create operation with given path, data, acls and mode.\n *\n * @method create\n * @param path {String} The znode path.\n * @param [data=undefined] {Buffer} The data buffer.\n * @param [acls=ACL.OPEN_ACL_UNSAFE] {Array} An array of ACL object.\n * @param [mode=CreateMode.PERSISTENT] {CreateMode} The creation mode.\n * @return {Transaction} this transaction instance.\n */\nTransaction.prototype.create = function (path, data, acls, mode) {\n    var optionalArgs = [data, acls, mode],\n        self = this,\n        currentPath = '',\n        nodes;\n\n    Path.validate(path);\n\n    // Reset arguments so we can reassign correct value to them.\n    data = acls = mode = undefined;\n    optionalArgs.forEach(function (arg, index) {\n        if (Array.isArray(arg)) {\n            acls = arg;\n        } else if (typeof arg === 'number') {\n            mode = arg;\n        } else if (Buffer.isBuffer(arg)) {\n            data = arg;\n        }\n    });\n\n    acls = Array.isArray(acls) ? acls : ACL.OPEN_ACL_UNSAFE;\n    mode = typeof mode === 'number' ? mode : CreateMode.PERSISTENT;\n\n    assert(\n        data === null || data === undefined || Buffer.isBuffer(data),\n        'data must be a valid buffer, null or undefined.'\n    );\n\n    assert(acls.length > 0, 'acls must be a non-empty array.');\n\n    this.ops.push({\n        type : jute.OP_CODES.CREATE,\n        path : path,\n        data : data,\n        acls : acls,\n        mode : mode\n    });\n\n    return this;\n};\n\n/**\n * Add a check (existence) operation with given path and optional version.\n *\n * @method check\n * @param path {String} The znode path.\n * @param [version=-1] {Number} The version of the znode.\n * @return {Transaction} this transaction instance.\n */\nTransaction.prototype.check = function (path, version) {\n    version = version || -1;\n\n    Path.validate(path);\n    assert(typeof version === 'number', 'version must be a number.');\n\n    this.ops.push({\n        type : jute.OP_CODES.CHECK,\n        path : path,\n        version : version\n    });\n\n    return this;\n};\n\n/**\n * Add a set-data operation with the given path, data and optional version.\n *\n * @method setData\n * @param path {String} The znode path.\n * @param data {Buffer} The data buffer.\n * @param [version=-1] {Number} The version of the znode.\n * @return {Transaction} this transaction instance.\n */\nTransaction.prototype.setData = function (path, data, version) {\n    version = version || -1;\n\n    Path.validate(path);\n    assert(\n        data === null || data === undefined || Buffer.isBuffer(data),\n        'data must be a valid buffer, null or undefined.'\n    );\n    assert(typeof version === 'number', 'version must be a number.');\n\n    this.ops.push({\n        type : jute.OP_CODES.SET_DATA,\n        path : path,\n        data : data,\n        version : version\n    });\n\n    return this;\n};\n\n/**\n * Add a delete operation with the given path and optional version.\n *\n * @method delete\n * @param path {String} The znode path.\n * @param [version=-1] {Number} The version of the znode.\n * @return {Transaction} this transaction instance.\n */\nTransaction.prototype.remove = function (path, version) {\n    version = version || -1;\n\n    Path.validate(path);\n    assert(typeof version === 'number', 'version must be a number.');\n\n    this.ops.push({\n        type : jute.OP_CODES.DELETE,\n        path : path,\n        version : version\n    });\n\n    return this;\n};\n\n/**\n * Execute the transaction atomically.\n *\n * @method commit\n * @param callback {Function} callback function.\n */\nTransaction.prototype.commit = function (callback) {\n    assert(typeof callback === 'function', 'callback must be a function');\n\n    var self = this,\n        header = new jute.protocol.RequestHeader(),\n        payload = new jute.TransactionRequest(this.ops),\n        request;\n\n    header.type = jute.OP_CODES.MULTI;\n    request = new jute.Request(header, payload);\n\n    this.connectionManager.queue(request, function (error, response) {\n        if (error) {\n            callback(error);\n            return;\n        }\n\n        var result,\n            i;\n\n        for (i = 0; i < response.payload.results.length; i += 1) {\n            result = response.payload.results[i];\n\n            // Find if there is an op which caused the transaction to fail.\n            if (result.type === jute.OP_CODES.ERROR &&\n                    result.err !== Exception.OK) {\n                error = Exception.create(result.err);\n                break;\n            }\n        }\n\n        callback(error, response.payload.results);\n    });\n};\n\n\nmodule.exports = Transaction;\n","/home/travis/build/npmtest/node-npmtest-node-zookeeper-client/node_modules/node-zookeeper-client/lib/ConnectionManager.js":"/**\n * Copyright (c) 2013 Yahoo! Inc. All rights reserved.\n *\n * Copyrights licensed under the MIT License. See the accompanying LICENSE file\n * for terms.\n */\n\nvar net = require('net');\nvar utils = require('util');\nvar events = require('events');\n\nvar jute = require('./jute');\nvar ConnectionStringParser = require('./ConnectionStringParser.js');\nvar WatcherManager = require('./WatcherManager.js');\nvar PacketQueue = require('./PacketQueue.js');\nvar Exception = require('./Exception.js');\n\n/**\n * This class manages the connection between the client and the ensemble.\n *\n * @module node-zookeeper-client\n */\n\n// Constants.\nvar STATES = { // Connection States.\n    DISCONNECTED : 0,\n    CONNECTING : 1,\n    CONNECTED : 2,\n    CONNECTED_READ_ONLY : 3,\n    CLOSING : -1,\n    CLOSED : -2,\n    SESSION_EXPIRED : -3,\n    AUTHENTICATION_FAILED : -4\n};\n\n\n/**\n * Construct a new ConnectionManager instance.\n *\n * @class ConnectionStringParser\n * @constructor\n * @param connectionString {String} ZooKeeper server ensemble string.\n * @param options {Object} Client options.\n * @param stateListener {Object} Listener for state changes.\n */\nfunction ConnectionManager(connectionString, options, stateListener) {\n    events.EventEmitter.call(this);\n\n    this.watcherManager = new WatcherManager();\n    this.connectionStringParser = new ConnectionStringParser(connectionString);\n\n    this.servers = this.connectionStringParser.getServers();\n    this.chrootPath = this.connectionStringParser.getChrootPath();\n    this.nextServerIndex = 0;\n    this.serverAttempts = 0;\n\n    this.state = STATES.DISCONNECTED;\n\n    this.options = options;\n    this.spinDelay = options.spinDelay;\n\n    this.updateTimeout(options.sessionTimeout);\n    this.connectTimeoutHandler = null;\n\n    this.xid = 0;\n\n    this.sessionId = new Buffer(8);\n    if (Buffer.isBuffer(options.sessionId)) {\n        options.sessionId.copy(this.sessionId);\n    } else {\n        this.sessionId.fill(0);\n    }\n\n    this.sessionPassword = new Buffer(16);\n    if (Buffer.isBuffer(options.sessionPassword)) {\n        options.sessionPassword.copy(this.sessionPassword);\n    } else {\n        this.sessionPassword.fill(0);\n    }\n\n    // scheme:auth pairs\n    this.credentials = [];\n\n    // Last seen zxid.\n    this.zxid = new Buffer(8);\n    this.zxid.fill(0);\n\n\n    this.pendingBuffer = null;\n\n    this.packetQueue = new PacketQueue();\n    this.packetQueue.on('readable', this.onPacketQueueReadable.bind(this));\n    this.pendingQueue = [];\n\n    this.on('state', stateListener);\n}\n\nutils.inherits(ConnectionManager, events.EventEmitter);\n\n/**\n * Update the session timeout and related timeout variables.\n *\n * @method updateTimeout\n * @private\n * @param sessionTimeout {Number} Milliseconds of the timeout value.\n */\nConnectionManager.prototype.updateTimeout = function (sessionTimeout) {\n    this.sessionTimeout = sessionTimeout;\n\n    // Designed to have time to try all the servers.\n    this.connectTimeout = Math.floor(sessionTimeout / this.servers.length);\n\n    // We at least send out one ping one third of the session timeout, so\n    // the read timeout is two third of the session timeout.\n    this.pingTimeout = Math.floor(this.sessionTimeout / 3);\n    //this.readTimeout = Math.floor(sessionTimeout * 2 / 3);\n};\n\n/**\n * Find the next available server to connect. If all server has been tried,\n * it will wait for a random time between 0 to spin delay before call back\n * with the next server.\n *\n * callback prototype:\n * callback(server);\n *\n * @method findNextServer\n * @param callback {Function} callback function.\n *\n */\nConnectionManager.prototype.findNextServer = function (callback) {\n    var self = this;\n\n    self.nextServerIndex %= self.servers.length;\n\n    if (self.serverAttempts === self.servers.length) {\n        setTimeout(function () {\n            callback(self.servers[self.nextServerIndex]);\n            self.nextServerIndex += 1;\n\n            // reset attempts since we already waited for enough time.\n            self.serverAttempts = 0;\n        }, Math.random() * self.spinDelay);\n    } else {\n        self.serverAttempts += 1;\n\n        process.nextTick(function () {\n            callback(self.servers[self.nextServerIndex]);\n            self.nextServerIndex += 1;\n        });\n    }\n};\n\n/**\n * Change the current state to the given state if the given state is different\n * from current state. Emit the state change event with the changed state.\n *\n * @method setState\n * @param state {Number} The state to be set.\n */\nConnectionManager.prototype.setState = function (state) {\n    if (typeof state !== 'number') {\n        throw new Error('state must be a valid number.');\n    }\n\n    if (this.state !== state) {\n        this.state = state;\n        this.emit('state', this.state);\n    }\n};\n\nConnectionManager.prototype.registerDataWatcher = function (path, watcher) {\n    this.watcherManager.registerDataWatcher(path, watcher);\n};\n\nConnectionManager.prototype.registerChildWatcher = function (path, watcher) {\n    this.watcherManager.registerChildWatcher(path, watcher);\n};\n\nConnectionManager.prototype.registerExistenceWatcher = function (path, watcher) {\n    this.watcherManager.registerExistenceWatcher(path, watcher);\n};\n\nConnectionManager.prototype.cleanupPendingQueue = function (errorCode) {\n    var pendingPacket = this.pendingQueue.shift();\n\n    while (pendingPacket) {\n        if (pendingPacket.callback) {\n            pendingPacket.callback(Exception.create(errorCode));\n        }\n\n        pendingPacket = this.pendingQueue.shift();\n    }\n};\n\nConnectionManager.prototype.getSessionId = function () {\n    var result = new Buffer(8);\n\n    this.sessionId.copy(result);\n    return result;\n};\n\nConnectionManager.prototype.getSessionPassword = function () {\n    var result = new Buffer(16);\n\n    this.sessionPassword.copy(result);\n    return result;\n};\n\nConnectionManager.prototype.getSessionTimeout = function () {\n    return this.sessionTimeout;\n};\n\nConnectionManager.prototype.connect = function () {\n    var self = this;\n\n    self.setState(STATES.CONNECTING);\n\n    self.findNextServer(function (server) {\n        self.socket = net.connect(server);\n\n        self.connectTimeoutHandler = setTimeout(\n            self.onSocketConnectTimeout.bind(self),\n            self.connectTimeout\n        );\n\n        // Disable the Nagle algorithm.\n        self.socket.setNoDelay();\n\n        self.socket.on('connect', self.onSocketConnected.bind(self));\n        self.socket.on('data', self.onSocketData.bind(self));\n        self.socket.on('drain', self.onSocketDrain.bind(self));\n        self.socket.on('close', self.onSocketClosed.bind(self));\n        self.socket.on('error', self.onSocketError.bind(self));\n    });\n};\n\nConnectionManager.prototype.close = function () {\n    var self = this,\n        header = new jute.protocol.RequestHeader(),\n        request;\n\n    self.setState(STATES.CLOSING);\n\n    header.type = jute.OP_CODES.CLOSE_SESSION;\n    request = new jute.Request(header, null);\n\n    self.queue(request);\n};\n\nConnectionManager.prototype.onSocketClosed = function (hasError) {\n    var retry = false,\n        errorCode,\n        pendingPacket;\n\n    switch (this.state) {\n    case STATES.CLOSING:\n        errorCode = Exception.CONNECTION_LOSS;\n        retry = false;\n        break;\n    case STATES.SESSION_EXPIRED:\n        errorCode = Exception.SESSION_EXPIRED;\n        retry = false;\n        break;\n    case STATES.AUTHENTICATION_FAILED:\n        errorCode = Exception.AUTH_FAILED;\n        retry = false;\n        break;\n    default:\n        errorCode = Exception.CONNECTION_LOSS;\n        retry = true;\n    }\n\n    this.cleanupPendingQueue(errorCode);\n    this.setState(STATES.DISCONNECTED);\n\n    if (retry) {\n        this.connect();\n    } else {\n        this.setState(STATES.CLOSED);\n    }\n};\n\nConnectionManager.prototype.onSocketError = function (error) {\n    if (this.connectTimeoutHandler) {\n        clearTimeout(this.connectTimeoutHandler);\n    }\n\n    // After socket error, the socket closed event will be triggered,\n    // we will retry connect in that listener function.\n};\n\nConnectionManager.prototype.onSocketConnectTimeout = function () {\n    // Destroy the current socket so the socket closed event\n    // will be trigger.\n    this.socket.destroy();\n};\n\nConnectionManager.prototype.onSocketConnected = function () {\n    var connectRequest,\n        authRequest,\n        setWatchesRequest,\n        header,\n        payload;\n\n    if (this.connectTimeoutHandler) {\n        clearTimeout(this.connectTimeoutHandler);\n    }\n\n    connectRequest = new jute.Request(null, new jute.protocol.ConnectRequest(\n        jute.PROTOCOL_VERSION,\n        this.zxid,\n        this.sessionTimeout,\n        this.sessionId,\n        this.sessionPassword\n    ));\n\n    // XXX No read only support yet.\n    this.socket.write(connectRequest.toBuffer());\n\n    // Set auth info\n    if (this.credentials.length > 0) {\n        this.credentials.forEach(function (credential) {\n            header = new jute.protocol.RequestHeader();\n            payload = new jute.protocol.AuthPacket();\n\n            header.xid = jute.XID_AUTHENTICATION;\n            header.type = jute.OP_CODES.AUTH;\n\n            payload.type = 0;\n            payload.scheme = credential.scheme;\n            payload.auth = credential.auth;\n\n            authRequest = new jute.Request(header, payload);\n            this.queue(authRequest);\n\n        },  this);\n    }\n\n    // Reset the watchers if we have any.\n    if (!this.watcherManager.isEmpty()) {\n        header = new jute.protocol.RequestHeader();\n        payload = new jute.protocol.SetWatches();\n\n        header.type = jute.OP_CODES.SET_WATCHES;\n        header.xid = jute.XID_SET_WATCHES;\n\n        payload.setChrootPath(this.chrootPath);\n        payload.relativeZxid = this.zxid;\n        payload.dataWatches = this.watcherManager.getDataWatcherPaths();\n        payload.existWatches = this.watcherManager.getExistenceWatcherPaths();\n        payload.childWatches = this.watcherManager.getChildWatcherPaths();\n\n        setWatchesRequest = new jute.Request(header, payload);\n        this.queue(setWatchesRequest);\n    }\n};\n\nConnectionManager.prototype.onSocketTimeout = function () {\n    var header,\n        request;\n\n    if (this.socket &&\n            (this.state === STATES.CONNECTED ||\n             this.state === STATES.CONNECTED_READ_ONLY)) {\n        header = new jute.protocol.RequestHeader(\n            jute.XID_PING,\n            jute.OP_CODES.PING\n        );\n\n        request = new jute.Request(header, null);\n        this.queue(request);\n\n        // Re-register the timeout handler since it only fired once.\n        this.socket.setTimeout(\n            this.pingTimeout,\n            this.onSocketTimeout.bind(this)\n        );\n    }\n};\n\nConnectionManager.prototype.onSocketData = function (buffer) {\n    var self = this,\n        offset = 0,\n        size = 0,\n        connectResponse,\n        pendingPacket,\n        responseHeader,\n        responsePayload,\n        response,\n        event;\n\n    // Combine the pending buffer with the new buffer.\n    if (self.pendingBuffer) {\n        buffer = Buffer.concat(\n            [self.pendingBuffer, buffer],\n            self.pendingBuffer.length + buffer.length\n        );\n    }\n\n    // We need at least 4 bytes\n    if (buffer.length < 4) {\n        self.pendingBuffer = buffer;\n        return;\n    }\n\n    size = buffer.readInt32BE(offset);\n    offset += 4;\n\n    if (buffer.length < size + 4) {\n        // More data are coming.\n        self.pendingBuffer = buffer;\n        return;\n    }\n\n    if (buffer.length === size + 4) {\n        // The size is perfect.\n        self.pendingBuffer = null;\n    } else {\n        // We have extra bytes, splice them out as pending buffer.\n        self.pendingBuffer = buffer.slice(size + 4);\n        buffer = buffer.slice(0, size + 4);\n    }\n\n    if (self.state === STATES.CONNECTING) {\n        // Handle connect response.\n        connectResponse = new jute.protocol.ConnectResponse();\n        offset += connectResponse.deserialize(buffer, offset);\n\n\n        if (connectResponse.timeOut <= 0) {\n            self.setState(STATES.SESSION_EXPIRED);\n\n        } else {\n            // Reset the server connection attempts since we connected now.\n            self.serverAttempts = 0;\n\n            self.sessionId = connectResponse.sessionId;\n            self.sessionPassword = connectResponse.passwd;\n            self.updateTimeout(connectResponse.timeOut);\n\n            self.setState(STATES.CONNECTED);\n\n            // Check if we have anything to send out just in case.\n            self.onPacketQueueReadable();\n\n            self.socket.setTimeout(\n                self.pingTimeout,\n                self.onSocketTimeout.bind(self)\n            );\n\n        }\n    } else {\n        // Handle  all other repsonses.\n        responseHeader = new jute.protocol.ReplyHeader();\n        offset += responseHeader.deserialize(buffer, offset);\n\n        //TODO BETTTER LOGGING\n        switch (responseHeader.xid) {\n        case jute.XID_PING:\n            break;\n        case jute.XID_AUTHENTICATION:\n            if (responseHeader.err === Exception.AUTH_FAILED) {\n                self.setState(STATES.AUTHENTICATION_FAILED);\n            }\n            break;\n        case jute.XID_NOTIFICATION:\n            event = new jute.protocol.WatcherEvent();\n\n            if (self.chrootPath) {\n                event.setChrootPath(self.chrootPath);\n            }\n\n            offset += event.deserialize(buffer, offset);\n            self.watcherManager.emit(event);\n            break;\n        default:\n            pendingPacket = self.pendingQueue.shift();\n\n            if (!pendingPacket) {\n                // TODO, better error handling and logging need to be done.\n                // Need to clean up and do a reconnect.\n                // throw new Error(\n                //    'Nothing in pending queue but got data from server.'\n                // );\n                self.socket.destroy(); // this will trigger reconnect\n                return;\n            }\n\n            if (pendingPacket.request.header.xid !== responseHeader.xid) {\n                // TODO, better error handling/logging need to bee done here.\n                // Need to clean up and do a reconnect.\n                //throw new Error(\n                    //'Xid out of order. Got xid: ' +\n                        //responseHeader.xid + ' with error code: ' +\n                        //responseHeader.err + ', expected xid: ' +\n                        //pendingPacket.request.header.xid + '.'\n                //);\n                self.socket.destroy(); // this will trigger reconnect\n                return;\n            }\n\n            if (responseHeader.zxid) {\n                // TODO, In Java implementation, the condition is to\n                // check whether the long zxid is greater than 0, here\n                // use buffer so we simplify.\n                // Need to figure out side effect.\n                self.zxid = responseHeader.zxid;\n            }\n\n            if (responseHeader.err === 0) {\n                switch (pendingPacket.request.header.type) {\n                case jute.OP_CODES.CREATE:\n                    responsePayload = new jute.protocol.CreateResponse();\n                    break;\n                case jute.OP_CODES.DELETE:\n                    responsePayload = null;\n                    break;\n                case jute.OP_CODES.GET_CHILDREN2:\n                    responsePayload = new jute.protocol.GetChildren2Response();\n                    break;\n                case jute.OP_CODES.EXISTS:\n                    responsePayload = new jute.protocol.ExistsResponse();\n                    break;\n                case jute.OP_CODES.SET_DATA:\n                    responsePayload = new jute.protocol.SetDataResponse();\n                    break;\n                case jute.OP_CODES.GET_DATA:\n                    responsePayload = new jute.protocol.GetDataResponse();\n                    break;\n                case jute.OP_CODES.SET_ACL:\n                    responsePayload = new jute.protocol.SetACLResponse();\n                    break;\n                case jute.OP_CODES.GET_ACL:\n                    responsePayload = new jute.protocol.GetACLResponse();\n                    break;\n                case jute.OP_CODES.SET_WATCHES:\n                    responsePayload = null;\n                    break;\n                case jute.OP_CODES.CLOSE_SESSION:\n                    responsePayload = null;\n                    break;\n                case jute.OP_CODES.MULTI:\n                    responsePayload = new jute.TransactionResponse();\n                    break;\n                default:\n                    //throw new Error('Unknown request OP_CODE: ' +\n                        //pendingPacket.request.header.type);\n                    self.socket.destroy(); // this will trigger reconnect\n                    return;\n                }\n\n                if (responsePayload) {\n                    if (self.chrootPath) {\n                        responsePayload.setChrootPath(self.chrootPath);\n                    }\n\n                    offset += responsePayload.deserialize(buffer, offset);\n                }\n\n                if (pendingPacket.callback) {\n                    pendingPacket.callback(\n                        null,\n                        new jute.Response(responseHeader, responsePayload)\n                    );\n                }\n            } else {\n                if (pendingPacket.callback) {\n                    pendingPacket.callback(\n                        Exception.create(responseHeader.err),\n                        new jute.Response(responseHeader, null)\n                    );\n                }\n            }\n        }\n    }\n\n    // We have more data to process, need to recursively process it.\n    if (self.pendingBuffer) {\n        self.onSocketData(new Buffer(0));\n    }\n};\n\nConnectionManager.prototype.onSocketDrain = function () {\n    // Trigger write on socket.\n    this.onPacketQueueReadable();\n};\n\nConnectionManager.prototype.onPacketQueueReadable = function () {\n    var packet,\n        header;\n\n    switch (this.state) {\n    case STATES.CONNECTED:\n    case STATES.CONNECTED_READ_ONLY:\n    case STATES.CLOSING:\n        // Continue\n        break;\n    case STATES.DISCONNECTED:\n    case STATES.CONNECTING:\n    case STATES.CLOSED:\n    case STATES.SESSION_EXPIRED:\n    case STATES.AUTHENTICATION_FAILED:\n        // Skip since we can not send traffic out\n        return;\n    default:\n        throw new Error('Unknown state: ' + this.state);\n    }\n\n    while ((packet = this.packetQueue.shift()) !== undefined) {\n        header = packet.request.header;\n        if (header !== null &&\n                header.type !== jute.OP_CODES.PING &&\n                header.type !== jute.OP_CODES.AUTH) {\n\n            header.xid = this.xid;\n            this.xid += 1;\n\n            // Only put requests that are not connect, ping and auth into\n            // the pending queue.\n            this.pendingQueue.push(packet);\n        }\n\n        if (!this.socket.write(packet.request.toBuffer())) {\n            // Back pressure is handled here, when the socket emit\n            // drain event, this method will be invoked again.\n            break;\n        }\n\n        if (header.type === jute.OP_CODES.CLOSE_SESSION) {\n            // The close session should be the final packet sent to the\n            // server.\n            break;\n        }\n    }\n};\n\nConnectionManager.prototype.addAuthInfo = function (scheme, auth) {\n    if (!scheme || typeof scheme !== 'string') {\n        throw new Error('scheme must be a non-empty string.');\n    }\n\n    if (!Buffer.isBuffer(auth)) {\n        throw new Error('auth must be a valid instance of Buffer');\n    }\n\n    var header,\n        payload,\n        request;\n\n    this.credentials.push({\n        scheme : scheme,\n        auth : auth\n    });\n\n    switch (this.state) {\n    case STATES.CONNECTED:\n    case STATES.CONNECTED_READ_ONLY:\n        // Only queue the auth request when connected.\n        header = new jute.protocol.RequestHeader();\n        payload = new jute.protocol.AuthPacket();\n\n        header.xid = jute.XID_AUTHENTICATION;\n        header.type = jute.OP_CODES.AUTH;\n\n        payload.type = 0;\n        payload.scheme = scheme;\n        payload.auth = auth;\n\n        this.queue(new jute.Request(header, payload));\n        break;\n    case STATES.DISCONNECTED:\n    case STATES.CONNECTING:\n    case STATES.CLOSING:\n    case STATES.CLOSED:\n    case STATES.SESSION_EXPIRED:\n    case STATES.AUTHENTICATION_FAILED:\n        // Skip when we are not in a live state.\n        return;\n    default:\n        throw new Error('Unknown state: ' + this.state);\n    }\n};\n\nConnectionManager.prototype.queue = function (request, callback) {\n    if (typeof request !== 'object') {\n        throw new Error('request must be a valid instance of jute.Request.');\n    }\n\n    if (this.chrootPath && request.payload) {\n        request.payload.setChrootPath(this.chrootPath);\n    }\n\n\n    callback = callback || function () {};\n\n    switch (this.state) {\n    case STATES.DISCONNECTED:\n    case STATES.CONNECTING:\n    case STATES.CONNECTED:\n    case STATES.CONNECTED_READ_ONLY:\n        // queue the packet\n        this.packetQueue.push({\n            request : request,\n            callback : callback\n        });\n        break;\n    case STATES.CLOSING:\n        if (request.header &&\n                request.header.type === jute.OP_CODES.CLOSE_SESSION) {\n            this.packetQueue.push({\n                request : request,\n                callback : callback\n            });\n        } else {\n            callback(Exception.create(Exception.CONNECTION_LOSS));\n        }\n        break;\n    case STATES.CLOSED:\n        callback(Exception.create(Exception.CONNECTION_LOSS));\n        return;\n    case STATES.SESSION_EXPIRED:\n        callback(Exception.create(Exception.SESSION_EXPIRED));\n        return;\n    case STATES.AUTHENTICATION_FAILED:\n        callback(Exception.create(Exception.AUTH_FAILED));\n        return;\n    default:\n        throw new Error('Unknown state: ' + this.state);\n    }\n};\n\n\n\nmodule.exports = ConnectionManager;\nmodule.exports.STATES = STATES;\n","/home/travis/build/npmtest/node-npmtest-node-zookeeper-client/node_modules/node-zookeeper-client/lib/ConnectionStringParser.js":"/**\n * Copyright (c) 2013 Yahoo! Inc. All rights reserved.\n *\n * Copyrights licensed under the MIT License. See the accompanying LICENSE file\n * for terms.\n */\n\n\nvar assert = require('assert');\nvar u      = require('underscore');\nvar Path   = require('./Path.js');\n\n// Constants.\nvar DEFAULT_PORT = 2181; // Default Zookeeper client port.\n\n/**\n * This class parse the connection string to build the ensemble server\n * list and chrootPath.\n *\n * @module node-zookeeper-client\n */\n/**\n *\n * Parse the connect string and random the servers of the ensemble.\n *\n * @module node-zookeeper-client\n * @class ConnectionStringParser\n * @constructor\n * @param connectionString {String} ZooKeeper server ensemble string.\n */\nfunction ConnectionStringParser(connectionString) {\n    assert(\n        connectionString && typeof connectionString === 'string',\n        'connectionString must be a non-empty string.'\n    );\n\n    this.connectionString = connectionString;\n\n    // Handle chroot\n    var index = connectionString.indexOf('/'),\n        hostList = [],\n        servers = [];\n\n    if (index !== -1 && index !== (connectionString.length - 1)) {\n        this.chrootPath = connectionString.substring(index);\n        Path.validate(this.chrootPath);\n    } else {\n        this.chrootPath = undefined;\n    }\n\n    if (index !== -1) {\n        hostList = connectionString.substring(0, index).split(',');\n    } else {\n        hostList = connectionString.split(',');\n    }\n\n    hostList.filter(function (item) {\n        // Filter out empty string.\n        return item;\n    }).forEach(function (item) {\n        var parts = item.split(':');\n        servers.push({\n            host : parts[0],\n            port : parts[1] || DEFAULT_PORT\n        });\n    });\n\n    assert(\n        servers.length > 0,\n        'connectionString must contain at least one server.'\n    );\n\n    // Randomize the list.\n    this.servers = u.shuffle(servers);\n}\n\n/**\n * Return the connection string of this host provider.\n *\n * @method getConnectionString\n * @return The connection string.\n */\nConnectionStringParser.prototype.getConnectionString = function () {\n    return this.connectionString;\n};\n\nConnectionStringParser.prototype.getChrootPath = function () {\n    return this.chrootPath;\n};\n\nConnectionStringParser.prototype.getServers = function () {\n    return this.servers.slice(0);\n};\n\nmodule.exports = ConnectionStringParser;\n","/home/travis/build/npmtest/node-npmtest-node-zookeeper-client/node_modules/node-zookeeper-client/lib/WatcherManager.js":"/**\n * Copyright (c) 2013 Yahoo! Inc. All rights reserved.\n *\n * Copyrights licensed under the MIT License. See the accompanying LICENSE file\n * for terms.\n */\n\n\nvar events = require('events');\nvar Path = require('./Path.js');\nvar Event = require('./Event.js');\n\nfunction WatcherManager() {\n    this.dataWatchers = {};\n    this.childWatchers = {};\n    this.existenceWatchers = {};\n}\n\nfunction registerWatcher(self, type, path, watcher) {\n    var watchers = self[type + 'Watchers'],\n        watcherExists = false;\n\n    Path.validate(path);\n\n    if (typeof watcher !== 'function') {\n        throw new Error('watcher must be a valid function.');\n    }\n\n    watchers[path] = watchers[path] || new events.EventEmitter();\n    watcherExists = watchers[path].listeners('notification').some(function (l) {\n        // This is rather hacky since node.js wraps the listeners using an\n        // internal function.\n        return l === watcher || l.listener === watcher;\n    });\n\n    if (!watcherExists) {\n        watchers[path].once('notification', watcher);\n    }\n}\n\nfunction getWatcherPaths(self, type) {\n    var watchers = self[type + 'Watchers'],\n        result = [];\n\n    Object.keys(watchers).forEach(function (path) {\n        if (watchers[path].listeners('notification').length > 0) {\n            result.push(path);\n        }\n    });\n\n    return result;\n}\n\nWatcherManager.prototype.registerDataWatcher = function (path, watcher) {\n    registerWatcher(this, 'data', path, watcher);\n};\n\nWatcherManager.prototype.getDataWatcherPaths = function () {\n    return getWatcherPaths(this, 'data');\n};\n\nWatcherManager.prototype.registerChildWatcher = function (path, watcher) {\n    registerWatcher(this, 'child', path, watcher);\n};\n\nWatcherManager.prototype.getChildWatcherPaths = function () {\n    return getWatcherPaths(this, 'child');\n};\n\nWatcherManager.prototype.registerExistenceWatcher = function (path, watcher) {\n    registerWatcher(this, 'existence', path, watcher);\n};\n\nWatcherManager.prototype.getExistenceWatcherPaths = function () {\n    return getWatcherPaths(this, 'existence');\n};\n\nWatcherManager.prototype.emit = function (watcherEvent) {\n    if (!watcherEvent) {\n        throw new Error('watcherEvent must be a valid object.');\n    }\n\n    var emitters = [],\n        event;\n\n    switch (watcherEvent.type) {\n    case Event.NODE_DATA_CHANGED:\n    case Event.NODE_CREATED:\n        if (this.dataWatchers[watcherEvent.path]) {\n            emitters.push(this.dataWatchers[watcherEvent.path]);\n            delete this.dataWatchers[watcherEvent.path];\n        }\n\n        if (this.existenceWatchers[watcherEvent.path]) {\n            emitters.push(this.existenceWatchers[watcherEvent.path]);\n            delete this.existenceWatchers[watcherEvent.path];\n        }\n        break;\n    case Event.NODE_CHILDREN_CHANGED:\n        if (this.childWatchers[watcherEvent.path]) {\n            emitters.push(this.childWatchers[watcherEvent.path]);\n            delete this.childWatchers[watcherEvent.path];\n        }\n        break;\n    case Event.NODE_DELETED:\n        if (this.dataWatchers[watcherEvent.path]) {\n            emitters.push(this.dataWatchers[watcherEvent.path]);\n            delete this.dataWatchers[watcherEvent.path];\n        }\n        if (this.childWatchers[watcherEvent.path]) {\n            emitters.push(this.childWatchers[watcherEvent.path]);\n            delete this.childWatchers[watcherEvent.path];\n        }\n        break;\n    default:\n        throw new Error('Unknown event type: ' + watcherEvent.type);\n    }\n\n    if (emitters.length < 1) {\n        return;\n    }\n\n    event = Event.create(watcherEvent);\n\n    emitters.forEach(function (emitter) {\n        emitter.emit('notification', event);\n    });\n};\n\nWatcherManager.prototype.isEmpty = function () {\n    var empty = true,\n        watchers,\n        paths,\n        i,\n        j;\n\n    watchers = [this.dataWatchers, this.existenceWatchers, this.childWatchers];\n\n    for (i = 0; i < watchers.length; i += 1) {\n        paths = Object.keys(watchers[i]);\n\n        for (j = 0; j < paths.length; j += 1) {\n            if (watchers[i][paths[j]].listeners('notification').length > 0) {\n                empty = false;\n                break;\n            }\n        }\n    }\n\n    return empty;\n};\n\nmodule.exports = WatcherManager;\n","/home/travis/build/npmtest/node-npmtest-node-zookeeper-client/node_modules/node-zookeeper-client/lib/PacketQueue.js":"/**\n * Copyright (c) 2013 Yahoo! Inc. All rights reserved.\n *\n * Copyrights licensed under the MIT License. See the accompanying LICENSE file\n * for terms.\n */\n\n\n/**\n * The package queue which emits events.\n */\n\nvar util = require('util');\nvar events = require('events');\n\n\n\nfunction PacketQueue() {\n    events.EventEmitter.call(this);\n\n    this.queue = [];\n}\n\n\nutil.inherits(PacketQueue, events.EventEmitter);\n\n\nPacketQueue.prototype.push = function (packet) {\n    if (typeof packet !== 'object') {\n        throw new Error('packet must be a valid object.');\n    }\n\n    this.queue.push(packet);\n\n    this.emit('readable');\n};\n\n\nPacketQueue.prototype.unshift = function (packet) {\n    if (typeof packet !== 'object') {\n        throw new Error('packet must be a valid object.');\n    }\n\n    this.queue.unshift(packet);\n    this.emit('readable');\n};\n\nPacketQueue.prototype.shift = function () {\n    return this.queue.shift();\n};\n\n\nmodule.exports = PacketQueue;\n\n"}